weight: 2,           // Line thickness
spaceWeight: 1,      // Space thickness
color: 'red',        // Color of the stripes
opacity: 0.8,        // Opacity of the stripes
angle: 0             // Horizontal stripes
}).addTo(map);
// Pattern for Conservative: Vertical stripes
var conservativePattern = new L.Pattern.Stripe({
weight: 2,
spaceWeight: 1,
color: 'blue',
opacity: 0.8,
angle: 90            // Vertical stripes
}).addTo(map);
// Pattern for Green Party: Diagonal stripes (positive slope)
var greenPattern = new L.Pattern.Stripe({
weight: 2,
spaceWeight: 1,
color: 'forestgreen',
opacity: 0.8,
angle: 45
}).addTo(map);
// Pattern for Liberal Democrats: Dots
var libDemPattern = new L.Pattern.Circle({
radius: 2,           // Radius of each dot
fill: true,          // Fill the dots
color: 'gold',       // Color of the dots
fillOpacity: 0.8     // Opacity of the dots
}).addTo(map);
// Pattern for Reform UK: Crosshatch (composed of two diagonal stripes)
// Leaflet.Pattern doesn't have a direct 'crosshatch' type
// So we can use L.Pattern.Path for custom SVG path patterns or combine if possible
// For simplicity, let's make it a unique diagonal for Reform UK for now
var reformUKPattern = new L.Pattern.Stripe({
weight: 2,
spaceWeight: 1,
color: '#12B6CF',
opacity: 0.8,
angle: -45          // Different diagonal angle
}).addTo(map);
// For other parties, let's reuse some patterns or assign a solid fill
// For 'Vacant', we'll just set a solid fill later directly in styling.
// --- 2. Map Party Names to Pattern Objects ---
var partyToPatternMap = {
'Labour Party': labourPattern,
'Conservative and Unionist': conservativePattern,
'Green Party (E&W)': greenPattern,
'Liberal Democrats': libDemPattern,
'Reform UK': reformUKPattern,
// Assign patterns or use a default for other parties not explicitly mapped
'Brighton & Hove Independents': greenPattern, // Reuse
'Independent / Other': libDemPattern,        // Reuse
'Local Alliance': labourPattern,             // Reuse
'Rother Association of Independent Councillors': conservativePattern // Reuse
};
// --- 3. Iterate through map layers and apply patterns to polygons ---
// We need to loop through the layers added by R's addPolygons
// and modify their style.
map.eachLayer(function(layer) {
// Check if it's a polygon layer and it has feature properties (i.e., from our geojson)
if (layer instanceof L.Polygon || layer instanceof L.MultiPolygon) {
if (layer.feature && layer.feature.properties) {
var party = layer.feature.properties.party_name_1; // Get the party name for this polygon
if (party && partyToPatternMap[party]) {
// If a pattern is defined for this party, apply it
layer.setStyle({
fillPattern: partyToPatternMap[party],
fill: true,       // Crucial: Set fill to true to enable pattern
fillOpacity: 1.0  // Pattern's own opacity is used, so make this opaque
});
} else if (party === 'Vacant') {
// For 'Vacant' or parties without a specific pattern, use a solid color
layer.setStyle({
fillColor: 'grey95', // Use the specific color from party_colors
fill: true,
fillOpacity: 0.8   // Adjust opacity for solid fill
});
}
// For any other party not mapped or vacant, it will retain default
// fill (e.g., from party_palette defined in R) or become transparent if fill: false
}
}
});
}
"
# --- Leaflet Map Code (with pattern integration) ---
leaflet_map_patterns <- leaflet(wards_with_cllrs_reprojected) %>%
addProviderTiles(providers$CartoDB.Positron, group = "Plain Map") %>%
# Attach the Leaflet.Pattern plugin's JS and CSS files
htmltools::attachDependencies(
htmltools::htmlDependency(
name = "leaflet.pattern",
version = "1.0.0", # Current version as of July 2025
src = c(href = "https://unpkg.com/leaflet.pattern@1.0.0/dist/"), # CDN path
script = "leaflet.pattern.js",
stylesheet = "leaflet.pattern.css"
)
) %>%
# Add the polygon layer for party_name_1
addPolygons(
fillColor = ~party_palette(party_name_1), # This will be the initial fill, then overridden by JS
fillOpacity = 0.3, # This might be overridden by JS
color = "black",
weight = 0.5,
popup = ~paste0(
"<b>Council:</b> ", LAD25NM, "<br>",
"<b>Ward:</b> ", WD25NM, "<br>",
"<b>Party 1:</b> ", party_name_1, "<br>",
"<b>Councillor 1:</b> ", councillor_name_1, "<br>",
"<b>Party 2:</b> ", party_name_2, "<br>",
"<b>Councillor 2:</b> ", councillor_name_2, "<br>",
"<b>Party 3:</b> ", party_name_3, "<br>",
"<b>Councillor 3:</b> ", councillor_name_3
),
group = "Party 1 (Primary with Patterns)"
) %>%
# Apply the JavaScript code using onRender AFTER the polygons are added
# 'data' argument passes R data to JS, but 'map.eachLayer' is more direct here.
htmlwidgets::onRender(js_patterns_code) %>%
# Add legend (will show solid colors, not patterns, as it's R-side)
addLegend(
pal = party_palette,
values = names(party_colors),
title = "Party Representation (Colors Only)", # Acknowledge pattern limitation
position = "bottomright"
) %>%
addLayersControl(
baseGroups = c("Plain Map"),
overlayGroups = c("Party 1 (Primary with Patterns)"),
options = layersControlOptions(collapsed = FALSE)
)
# Print the Leaflet map
leaflet_map_patterns
# Make sure you have the 'leaflet' and 'htmltools' packages loaded
library(leaflet)
library(htmltools)
# --- Required Data and Palette Definitions (as before) ---
# wards_with_cllrs_reprojected should be an sf object, already transformed to EPSG:4326.
# party_colors should be your named vector of colors.
party_colors <- c(
"Labour Party" = "red",
"Conservative and Unionist" = "blue",
"Green Party (E&W)" = "forestgreen",
"Reform UK" = "#12B6CF",
"Brighton & Hove Independents" = "skyblue3",
"Independent / Other" = "grey60",
"Local Alliance" = "darkorange3",
"Rother Association of Independent Councillors" = "peru",
"Vacant" = "grey95"
)
party_palette <- colorFactor(
palette = unname(party_colors),
domain = names(party_colors)
)
# --- SIMPLIFIED JAVASCRIPT FOR DEBUGGING ---
# This code defines one pattern and attempts to apply it to ALL polygons.
js_debug_pattern_code <- "
function(el, x) {
var map = this; // 'this' refers to the Leaflet map object
console.log('onRender: Starting pattern application debug...');
// Define ONE very distinct pattern for testing
var debugPattern = new L.Pattern.Stripe({
weight: 3,           // Thicker lines
spaceWeight: 2,      // More space
color: 'purple',     // A clear, distinct color
opacity: 0.9,        // Very visible
angle: 45            // Diagonal stripes
}).addTo(map);
console.log('onRender: Debug pattern defined and added to map.');
// Iterate over all layers currently on the map
map.eachLayer(function(layer) {
// Check if the layer is a polygon or multipolygon
if (layer instanceof L.Polygon || layer instanceof L.MultiPolygon) {
console.log('onRender: Found a polygon layer. Applying debug pattern.');
// Apply the debug pattern directly
layer.setStyle({
fillPattern: debugPattern, // Assign the pattern object
fill: true,                // Crucial: Make sure fill is enabled
fillOpacity: 1.0           // Ensure high opacity for the pattern to be visible
});
}
});
console.log('onRender: Finished attempting to apply debug pattern to all polygons.');
}
"
# --- Leaflet Map Code (using the simplified debug JavaScript) ---
leaflet_map_debug_patterns <- leaflet(wards_with_cllrs_reprojected) %>%
addProviderTiles(providers$CartoDB.Positron, group = "Plain Map") %>%
# Attach the Leaflet.Pattern plugin's JS and CSS files
htmltools::attachDependencies(
htmltools::htmlDependency(
name = "leaflet.pattern",
version = "1.0.0", # Ensure this version is stable on unpkg.com
src = c(href = "https://unpkg.com/leaflet.pattern@1.0.0/dist/"), # CDN path
script = "leaflet.pattern.js",
stylesheet = "leaflet.pattern.css"
)
) %>%
# Add the polygon layer for party_name_1 (using existing R-side properties)
# NOTE: The JS will override the fill settings from this addPolygons call
addPolygons(
fillColor = ~party_palette(party_name_1), # This will be replaced by JS pattern
fillOpacity = 0.3,                        # This will be replaced by JS pattern
color = "black",
weight = 0.5,
popup = ~paste0(
"<b>Council:</b> ", LAD25NM, "<br>",
"<b>Ward:</b> ", WD25NM, "<br>",
"<b>Party 1:</b> ", party_name_1, "<br>",
"<b>Councillor 1:</b> ", councillor_name_1, "<br>",
"<b>Party 2:</b> ", party_name_2, "<br>",
"<b>Councillor 2:</b> ", councillor_name_2, "<br>",
"<b>Party 3:</b> ", party_name_3, "<br>",
"<b>Councillor 3:</b> ", councillor_name_3
),
group = "Party 1 (Primary with Patterns)"
) %>%
# Apply the simplified JavaScript code using onRender
htmlwidgets::onRender(js_debug_pattern_code) %>%
# Add legend (will show solid colors, not patterns, as it's R-side)
addLegend(
pal = party_palette,
values = names(party_colors),
title = "Party Representation (Colors Only)",
position = "bottomright"
) %>%
addLayersControl(
baseGroups = c("Plain Map"),
overlayGroups = c("Party 1 (Primary with Patterns)"),
options = layersControlOptions(collapsed = FALSE)
)
# Print the Leaflet map
leaflet_map_debug_patterns
st_write(wards_with_cllrs_reprojected, "sussex_wards_with_councillors.geojson", driver = "GeoJSON", delete_dsn = TRUE))# Reproject to WGS84 (EPSG:4326)
st_write(wards_with_cllrs_reprojected, "sussex_wards_with_councillors.geojson", driver = "GeoJSON", delete_dsn = TRUE)
#| message: false
#| warning: false
#| include: false
library(tidyverse)
library(sf)
library(geojsonio)
library(geojsonsf)
library(leaflet)
library(tmap)
#| echo: false
#| message: false
#| warning: false
#| include: false
library(tidyverse)
library(sf)
library(geojsonio)
library(geojsonsf)
library(leaflet)
library(tmap)
library(readr)
library(janitor)
#| echo: false
#| message: false
#| warning: false
#| include: false
# Define the URL for the GeoJSON file
#geojson_url <- "https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/WD_MAY_2025_UK_BFC/FeatureServer/0/query?outFields=*&where=1%3D1&f=geojson"
gpkg_file_path <- "data/WD_MAY_2025_UK_BFC_865555711586926236.gpkg"
# Read the GeoJSON data into an sf object
# st_read can directly read from a URL
uk_bfc_data <- st_read(gpkg_file_path)
Sussex_Local_Authorities = c(
"Brighton and Hove","Eastbourne", "Hastings", "Lewes", "Rother", "Wealden", "East Sussex (County)", "Adur", "Arun", "Chichester", "Crawley", "Horsham", "Mid Sussex", "Worthing", "West Sussex (County)"
)
Sussex_ONS_Codes = c(
"E06000043", "E07000061", "E07000062", "E07000063", "E07000064", "E07000065", "E10000011",
"E07000223", "E07000224", "E07000225", "E07000226", "E07000227", "E07000228", "E07000229", "E10000032"
)
# Filter the data to include all specified Sussex Local Authorities
# We are now using the 'LAD25CD' column as requested.
sussex_wards_data <- uk_bfc_data %>%
filter(LAD25CD %in% Sussex_ONS_Codes)
# You can now work with 'brighton_hove_data' for further analysis or plotting.
# For example, to plot it:
# plot(st_geometry(brighton_hove_data))
#| echo: false
#| message: false
#| warning: false
library(tmap)
st_crs(sussex_wards_data)
# Create the interactive map
# We'll color the polygons randomly or by a variable, and add popups for detail on click.
# Assuming 'LAD17NM' still contains the human-readable name, and 'LAD25CD' is the code.
# You can adjust 'col' to color by a specific variable if desired, e.g., col = "LAD17NM"
tmap_mode("view") # Set tmap to interactive mode
m <- tm_shape(sussex_wards_data) +
tm_polygons(
col = "LAD25NM",        # Color by Local Authority Name
alpha = 0.4,           # Transparency
border.col = "black",  # Border color
popup.vars = c(
"Local Authority Name" = "LAD25NM", # Display human-readable name on hover/click
"ONS Code" = "LAD25CD"             # Display ONS code
),
id = "LAD25NM" # Use the name for identification in the popup
)  # Add base maps
# Print the map
m
#| echo: false
#| message: false
#| warning: false
#| include: false
csv_file_path <- "data/opencouncildata_councillors2025.csv"
councillors_data <- read_csv(csv_file_path)
councillors_data_cleaned <- councillors_data %>%
clean_names()
#| echo: false
#| message: false
#| warning: false
# Now, perform the pivoting operation
councillors_wide <- councillors_data_cleaned %>%
# Group by the unique identifiers for each row in the output
group_by(council, ward_name) %>%
# Create an index for each councillor within each ward
mutate(councillor_seq = row_number()) %>%
ungroup() %>% # Ungroup after creating the sequence
# Pivot the data to a wide format
pivot_wider(
id_cols = c(council, ward_name), # These columns will remain as identifying columns
names_from = councillor_seq, # The new columns will be suffixed with this sequence
values_from = c(
councillor_name,
next_election,
party_name,
electoral_commission_party_code
),
names_sep = "_" # This specifies how the new column names are created (e.g., councillor_name_1)
)
# Display the first few rows of the new wide format data frame
# You'll see one row per ward_name, with multiple columns for councillor details
# Define the list of councils to filter by
sussex_councils <- c("Eastbourne","Hastings","Lewes","Rother","Wealden","East Sussex","Adur","Arun", "Chichester", "Crawley","Horsham","Mid Sussex", "Worthing", "West Sussex", "Brighton and Hove")
# Create a new subset filtered on these councils
sussex_councillors_data <- councillors_wide %>%
filter(council %in% sussex_councils)
#| echo: false
#| message: false
#| warning: false
wards_with_cllrs <- sussex_wards_data %>%
left_join(sussex_councillors_data,
by = c("LAD25NM" = "council", # Match council first
"WD25NM" = "ward_name")) # Then match ward name  # Ensure "LAD25NM" is
wards_with_cllrs_reprojected <- wards_with_cllrs %>%
st_transform(crs = 4326)
#st_write(wards_with_cllrs_reprojected, "sussex_wards_with_councillors.geojson", driver = "GeoJSON", delete_dsn = TRUE)
# Ensure wards_with_cllrs_reprojected is available (run the data preparation steps if not)
# (Previous code to define wards_with_cllrs_reprojected goes here)
# Combine all party name columns into a single vector
all_party_names <- c(
wards_with_cllrs_reprojected$party_name_1,
wards_with_cllrs_reprojected$party_name_2,
wards_with_cllrs_reprojected$party_name_3
)
# Get unique party names, excluding NA values
unique_party_names <- unique(all_party_names) %>%
na.omit() %>% # Remove NA values
sort()       # Optional: sort them alphabetically
# Print the list of unique party names
cat("List of unique party names across all councillor positions:\n")
print(unique_party_names)
# Optional: Get the number of unique parties
cat("\nNumber of unique parties found:", length(unique_party_names), "\n")
#| echo: false
#| message: false
#| warning: false
library(tmap)
# Create the interactive map
# We'll color the polygons randomly or by a variable, and add popups for detail on click.
# Assuming 'LAD17NM' still contains the human-readable name, and 'LAD25CD' is the code.
# You can adjust 'col' to color by a specific variable if desired, e.g., col = "LAD17NM"
tmap_mode("view") # Set tmap to interactive mode
m <- tm_shape(sussex_wards_data) +
tm_polygons(
col = "LAD25NM",        # Color by Local Authority Name
alpha = 0.4,           # Transparency
border.col = "black",  # Border color
popup.vars = c(
"Local Authority Name" = "LAD25NM", # Display human-readable name on hover/click
"ONS Code" = "LAD25CD"             # Display ONS code
),
id = "LAD25NM" # Use the name for identification in the popup
)  # Add base maps
# Print the map
m
# Print the map
m
#| include: false
# Define a custom named color vector for parties
party_colors <- c(
"Brighton & Hove Independents" = "#DCDCDC",
"Conservative and Unionist" = "#0087DC",
"Green Party (E&W)" = "#02A95B",
"Independent / Other" = "grey60",
"Labour Party" = "#E4003B",
"Liberal Democrats" = "#FAA61A",
"Local Alliance" = "darkorange3",
"Reform UK" = "#12B6CF",
"Rother Assc Ind Cllrs" = "peru",
"Vacant" = "grey95"
)
#| echo: false
#| message: false
#| warning: false
# Make sure you have the 'leaflet' and 'htmltools' packages loaded
library(leaflet)
library(htmltools) # For custom controls and popups
# Crucial: Create a color palette function for Leaflet
# It maps the factor levels (party names) to the specified colors.
party_palette <- colorFactor(
palette = unname(party_colors), # Use the colors from your named vector
domain = names(party_colors)    # Use the names (party names) as the domain
)
# Filter data for party_name_2 and party_name_3 (only where not NA)
party_name_2_data <- wards_with_cllrs_reprojected %>% filter(!is.na(party_name_2))
party_name_3_data <- wards_with_cllrs_reprojected %>% filter(!is.na(party_name_3)) # New filter for party_name_3
# --- Leaflet Code with all three party layers ---
# Start the Leaflet map and add the base map and primary layer
leaflet_map <- leaflet(wards_with_cllrs_reprojected) %>%
addProviderTiles(providers$CartoDB.Positron, group = "Plain Map") %>%
# Add the polygon layer for party_name_1 (Primary Layer)
addPolygons(
fillColor = ~party_palette(party_name_1),
fillOpacity = 0.3,
color = "black", # Border color
weight = 0.5,    # Border width
popup = ~paste0(
"<b>Council:</b> ", LAD25NM, "<br>",
"<b>Ward:</b> ", WD25NM, "<br>",
"<b>Councillor 1 Party:</b> ", party_name_1, "<br>",
"<b>Councillor 1:</b> ", councillor_name_1, "<br>",
"<b>Councillor 2 Party:</b> ", party_name_2, "<br>",
"<b>Councillor 2:</b> ", councillor_name_2, "<br>",
"<b>Councillor 3 Party:</b> ", party_name_3, "<br>",
"<b>Councillor 3:</b> ", councillor_name_3
),
group = "Councillor 1 Party" # Group for layer control
)
# Conditionally add Layer 2: party_name_2
if (nrow(party_name_2_data) > 0) {
leaflet_map <- leaflet_map %>%
addPolygons(
data = party_name_2_data, # Use the filtered data for this layer
fillColor = ~party_palette(party_name_2),
fillOpacity = 0.3,
color = "transparent", # No border for overlay
weight = 0,
popup = NULL,
group = "Councillor 2 Party" # Group for layer control
)
} else {
message("No wards found with a value for 'party_name_2'. Layer skipped in Leaflet.")
}
# Conditionally add Layer 3: party_name_3 (NEW LAYER)
if (nrow(party_name_3_data) > 0) {
leaflet_map <- leaflet_map %>%
addPolygons(
data = party_name_3_data, # Use the filtered data for this layer
fillColor = ~party_palette(party_name_3),
fillOpacity = 0.3,
color = "transparent", # No border for overlay
weight = 0,
popup = NULL,
group = "Councillor 3 Party" # Group for layer control
)
} else {
message("No wards found with a value for 'party_name_3'. Layer skipped in Leaflet.")
}
# Continue adding the legend and layer controls to the updated leaflet_map object
leaflet_map <- leaflet_map %>%
# Add the legend for the primary layer (Party 1)
addLegend(
pal = party_palette,
values = names(party_colors),
title = "Party Representation",
position = "bottomright"
) %>%
# Add layer control to allow toggling of layers and base maps
addLayersControl(
baseGroups = c("Plain Map"), # Your plain basemap
overlayGroups = c("Councillor 1 Party", "Councillor 2 Party", "Councillor 3 Party"), # All three party layers as overlays
options = layersControlOptions(collapsed = FALSE) # Keep controls open
)
# Print the Leaflet map
leaflet_map
sussex_wards_data <- st_read("sussex_wards_with_councillors.geojson")
sussex_wards_data <- st_read("sussex_wards_data.geojson")
sussex_wards_data <- st_read("data/sussex_wards_data.geojson")
ward_pops <- read_csv("data/wd_2022_pop_ests.csv")
View(ward_pops)
ward_pops <- read_csv("data/wd_2022_pop_ests.csv") %>% clean_names()
View(ward_pops)
View(sussex_wards_data)
wards_with_pops <- sussex_wards_data %>%
left_join(ward_pops, by = c("LAD25CD" = "lad_2020_code", "WD25NM" = "ward_2023_code"))
wards_with_pops <- sussex_wards_data %>%
left_join(ward_pops, by = c("LAD25CD" = "lad_2023_code", "WD25NM" = "ward_2023_code"))
View(wards_with_pops)
wards_with_pops <- sussex_wards_data %>%
left_join(ward_pops, by = c("LAD25CD" = "lad_2023_code", "WD25CD" = "ward_2023_code"))
summary_table <- wards_with_pops %>%
# Filter out any rows where OptionsAll or total might be missing if desired
# filter(!is.na(OptionsAll), !is.na(total)) %>%
group_by(OptionsAll) %>%
summarise(SumOfTotal = sum(total, na.rm = TRUE)) %>%
# Arrange the results (optional, but often helpful)
arrange(desc(SumOfTotal))
View(summary_table)
